# 附录 Appendix

## 类型统一规则 Type unification rules

类型统一规则描述了两种类型是否以及如何统一。精确的细节与 Go 实现相关，影响错误消息的细节（例如编译器是否报告类型推断或其他错误），并且可以解释为什么类型推断在异常代码情况下失败。但总的来说，在编写 Go 代码时可以忽略这些规则：类型推断的设计主要是“按预期工作”，并且统一规则会相应地进行微调。

类型统一由匹配模式控制，可以是精确的，也可以是宽松的。当统一递归地下降复合类型结构时，用于该类型的元素的匹配模式（元素匹配模式）保持与匹配模式相同，除非两个类型统一为可分配性（≡<sub>A</sub>）：在这种情况下，匹配模式在顶层是宽松的，但随后更改为元素类型的精确模式，反映了类型不必相同即可分配的事实。

如果以下任一条件为真，两个未绑定类型参数的类型就会完全统一：

- 两种类型是相同的。

- 两种类型具有相同的结构，并且它们的元素类型完全统一。

- 正好有一个类型是核心类型的非绑定类型参数，该核心类型根据≡<sub>A</sub> 的统一规则（顶层的松散统一和元素类型的精确统一）与另一个类型统一。

如果两种类型都是绑定类型参数，则它们根据给定的匹配模式进行统一，如果：

- 两个类型参数是相同的。

- 最多一个类型形参具有已知的类型实参。在这种情况下，类型参数被连接：它们都代表相同的类型参数。如果两个类型形参都没有已知的类型实参，则同时为这两个类型形参推断出为其中一个类型形参推断的未来类型实参。

- 两个类型参数都有一个已知的类型参数，并且类型参数根据给定的匹配模式进行统一。

单个绑定类型参数 P 和另一个类型 T 根据给定的匹配模式进行统一，如果：

- P 没有已知的类型参数。在这种情况下，T 被推断为 P 的类型参数。

- P 确实有一个已知类型参数 A，A 和 T 按照给定的匹配模式统一，并且以下条件之一为真：
  
  - A 和 T 都是接口类型：在这种情况下，如果 A 和 T 也是定义类型，则它们必须相同。否则，如果它们都不是定义的类型，则它们必须具有相同数量的方法（A 和 T 的统一已经确定方法匹配）。
  
  - A 和 T 都不是接口类型：在这种情况下，如果 T 是已定义类型，则 T 会替换 A 作为 P 的推断类型参数。

最后，如果满足以下条件，则两种未绑定类型参数的类型会松散地统一（并且根据元素匹配模式）：

- 两种类型完全统一。

- 一种类型是已定义的类型，另一种类型是类型文字，但不是接口，它们的底层类型按照元素匹配模式统一。

- 两种类型都是具有相同类型术语的接口（但不是类型参数），都嵌入或都不嵌入预声明的可比较类型，相应的方法类型根据元素匹配模式进行统一，并且其中一个接口的方法集是该方法集的子集的另一个接口。

- 只有一种类型是接口（但不是类型参数），两种类型对应的方法按照元素匹配方式统一，并且接口的方法集是另一种类型的方法集的子集。

- 两种类型具有相同的结构，并且它们的元素类型根据元素匹配模式进行统一。
