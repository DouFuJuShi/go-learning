# Go内存模型

## 介绍

Go 内存模型规定了在哪些条件下，可以保证读取一个 goroutine 中的变量时，能观察到写入不同 goroutine 中同一变量时产生的值。

### 建议

修改同时被多个程序访问的数据的程序必须将这种访问序列化。

要串行化访问，请使用通道操作或其他同步原语（例如sync 和sync/atomic 包中的同步原语）保护数据。

如果你必须阅读本文档的其余部分才能理解程序的行为，那你就太聪明了。

别自作聪明。

### 非正式概述

Go 的内存模型处理方式与该语言的其他部分大致相同，旨在保持语义简单、易于理解和有用。本节提供了该方法的总体概述，对于大多数程序员来说应该足够了。内存模型将在下一节中更正式地指定。

数据竞争被定义为对内存位置的写入与对同一位置的另一次读取或写入同时发生，除非涉及的所有访问都是由sync/atomic包提供的原子数据访问。如前所述，强烈鼓励程序员使用适当的同步来避免数据争用。在没有数据竞争的情况下，Go 程序的行为就像所有 goroutine 都复用到单个处理器上一样。此属性有时称为 DRF-SC：无数据争用程序以顺序一致的方式执行。

虽然程序员应该编写没有数据竞争的 Go 程序，但 Go 实现在响应数据竞争方面可以做的事情是有限的。实现总是可以通过报告竞争并终止程序来对数据竞争做出反应。否则，每次读取单字大小或子字大小的内存位置都必须观察实际写入该位置的值（可能是通过并发执行的 goroutine）且尚未被覆盖。这些实现限制使 Go 更像 Java 或 JavaScript，因为大多数竞赛的结果数量有限，而不像 C 和 C++，其中任何带有竞赛的程序的含义完全未定义，并且编译器可以做任何事情。 Go 的方法旨在使错误的程序更可靠、更容易调试，同时仍然坚持竞争是错误，并且工具可以诊断和报告它们。

## 内存模型

Go 内存模型的以下正式定义紧密遵循 Hans-J 提出的方法。 Boehm 和 Sarita V. Adve 在“Foundations of the C++ Concurrency Memory Model”中，发表于 PLDI 2008。数据竞争自由程序的定义和竞争自由程序的顺序一致性保证与该工作中的相同。

内存模型描述了程序执行的要求，程序执行由 goroutine 执行组成，而 goroutine 执行又由内存操作组成。

内存操作由四个细节建模：

- 它的种类，表明是普通的数据读取、普通的数据写入，还是原子数据访问、互斥操作、通道操作等同步操作，

- 它在程序中的位置，

- 正在访问的内存位置或变量，以及

- 操作读取或写入的值。

有些内存操作是类似读操作的，包括读取、原子读取、互斥锁、通道接收；其他操作是类似写操作，包括写、原子写、互斥解锁、通道发送和通道关闭；有些操作，既类似读操作，也类似写操作。

goroutine 执行被模拟为由单个 goroutine 执行的一组内存操作。

**要求 1：** 考虑到从内存中读取和写入的值，每个 Goroutine 中的内存操作必须对应于该 Goroutine 的正确顺序执行。该执行必须与先序关系一致，先序关系定义为 Go 语言规范为 Go 的控制流构造以及表达式求值的顺序规定的偏序要求。

Go 程序执行被建模为一组 goroutine 执行，以及指定每个类读操作从中读取的类写操作的映射 W。 （同一程序的多次执行可以有不同的程序执行。）

**要求 2**:  对于给定的程序执行，映射W仅限于同步操作时，必须通过某种隐含的同步操作的总顺序来解释，该操作与测序一致，并且值由这些操作读取和编写的值。

同步前关系是同步内存操作的偏序，源自 W。如果同步类读内存操作 r 观察到同步类写内存操作 w（即，如果 W(r) = w），则 w在 r 之前同步。非正式地，同步前关系是上一段提到的隐含全序的子集，仅限于 W 直接观察到的信息。

发生在关系之前定义为排序之前关系和同步之前关系的并集的传递闭包。
